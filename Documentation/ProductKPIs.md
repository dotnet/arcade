# Product KPIs (PKPIs)

This document describes product KPIs that can be used to determine the 'health' of
the overall product.

## Goals of PKPIs

Traditional KPIs used by the engeering services team measure metrics like service reliability,
service availability, queue wait times, etc. Analysis of the indicators (e.g.
against a baseline expected value) helps the engineering team determine whether
action needs to be taken to ensure that the product can build and ship on time.
For example, a spike in Helix queue times will affect how fast PRs can be
validated, which in turn affects how fast the product can iterate.

Though product KPIs bear limited resemeblence to traditional service KPIs, the
goal is largely the same:

**Ensure that the product can iterate and ship quickly with high quality by
identifying problem areas early and often.**

## Metrics

The desired product KPI metrics are listed below, with the following fields:
- **Name** - Name of metric
- **Qualifier** - How is this metric broken out? For example, dependency update
  PR merge time broken out by input channel, or are all dependency update PRs
  aggregated per repo. Is this metric an aggregator of all repos underneath it?
  For example, staleness can be aggregated such that even if all direct inputs
  to a repository A are new, if those inputs have stale inputs, then A is viewed
  as stale.

| Name | Qualifier | Indicates |
| ---- | --------- | --------- |
| **Open Dependency Update PRs vs. Possible Dependency Update PRs** | Per Input Channel, Per Repo | A large number of open dependency update PRs indicates that dependencies are not flowing through the repository node. This may indicate that auto-merge is not available for the repository, that the repository owners are not keeping up with merging updates.<br/>The metric is qualified based on the input channel because the focus of the team shifts between channels at different stages of the product cycle. |
| **Direct Product Dependency Staleness** | Per Output Channel, Per Repo | Measures the staleness of the direct *product* inputs of a repository, ignoring pinned dependencies. An dependency's staleness is measured against the latest version of the dependency applied to the input channel.<br/>For example, if the repository has dependency 'Foo.Bar', and 'Foo.Bar' is updated with a subscription to repo 'A' on channel 'Dev', then the dependency is not considered stale if repo A has produced no new builds containing Foo.Bar on channel Dev.<br/>A higher degree of staleness indicates that the repo is out of date vs. possibile inputs, and there may be a higher possibility of surprise breaks when it does catch up. This indicator is more important in a day to day Dev channel, especially right before branching for a release. |
| **Direct Toolset Dependency Staleness** | Per Output Channel, Per Repo | Measures the staleness of the direct *toolset* inputs of a repository, ignoring pinned dependencies. An dependency's staleness is measured against the latest version of the dependency applied to the input channel.<br/>For example, if the repository has dependency 'Foo.Bar', and 'Foo.Bar' is updated with a subscription to repo 'A' on channel 'Dev', then the dependency is not considered stale if repo A has produced no new builds containing Foo.Bar on channel Dev.<br/>A higher degree of staleness indicates that the repo is out of date vs. possibile inputs, and there may be a higher possibility of surprise breaks when it does catch up. This indicator is often less important than product staleness, as toolset inputs are used largely for test and arcade dependencies. However, a very stale test-only dependency may be hiding some kind of breaking change that may only appear when the repository's outputs roll up into the SDK. |
| **Transitive Product Staleness** | Per Output Channel, Per Repo | Measures the staleness of the direct *product* inputs of a repository, aggregated with the staleness of the dependencies of those inputs, onward down the repository dependency graph. Staleness calculations are broken at cycles.<br/>In contrast to direct dependency staleness, a repository may have a positive staleness score for its direct inputs. However, if those inputs have old dependencies, then the transitive product staleness will increase. A high degree of staleness indicates a higher possibility of breaks as inputs come up to date, that dependencies may not be smoothly flowing through a node, etc. |
| **Official Build Time** | Per Repo, Per default output channel | Measures the median build time of *successful* official builds of a branch that are applied by default to the specified channel. This should include time for retries. A large official build time indicates that it is slow to move dependencies through the node or get new outputs from the node, and that failures in the official build that require retries will be expensive, potentially putting ship schedules at risk. |
| **Official Build Pass Rate** | Per Repo, Per default output channel | Measures the average 'without intervention' pass rate over the last N days of builds of a branch that are applied by default to the specified channel. A build that is retried after an initial failure counts as a failure. A low pass rate indicates that dependencies or new content will not flow easily through the node, potentially putting ship schedules at risk. |
| **Release Pipeline Time** | Per associated release pipeline | Measures the median amount of time for a successful run of a release pipeline associated with a specific channel. A slow release pipeline time indicates a risk to the flow of dependencies through the product.  |
| **Release Pipeline Pass Rate** | Per output channel | Measures the average pass rate of a release pipeline associated with a specific channel. A low pass rate indicates a indicates a risk to the flow of dependencies through the product.  |
| **Dependency Update PR Merge Time** | Per Repo, Per default output channel | Measures the median amount of time from dependency PR creation to dependency PR merge for PRs to branches that will apply to a specified default output channel once merged. A high merge time may indicate any number of issues, like the rate of incoming change is faster than the PR build time or that the PR pass rate is low, but generally indicates that dependencies will have trouble flowing through the node. |
| **Dependency Update PR CI Time** | Per Repo, Per default output channel | Measures the median build time of *successful* PR builds targeting a branch that is applied by default to the specified channel. This should include time for retries. A large PR build time indicates that it is slow to move dependencies through the node or get new outputs from the node, and that failures in the official build that require retries will be expensive, potentially putting ship schedules at risk. This represents a subset of the PR merge time. |
| **Dependency Update PR CI Pass Rate** | Per Repo, Per default output channel | Measures the average 'without intervention' pass rate over the last N days of dependency update PRs targeting a branch that is applied by default to the specified channel. A build that is retried after an initial failure counts as a failure. A low pass rate indicates that dependencies or will not flow easily through the node, potentially putting ship schedules at risk. This may mean that there are flaky tests, that the rate of breaking changes is high, etc. |
| **Existence of Automated dependency Flow Cycles** | Per Channel | Indicates the existence/non-existence of cycles within the dependency flow graph that will flow without intervention. A subscription will flow without intervention if it is not disabled and its frequency is not 'none'. This metric is a shorthand way of saying that the product will never become coherent if 'real' product changes in the repositories are halted, potentially putting ship schedules at risk. In Dev channels, this is not an interesting metric. |
| **Existence of cross-channel flow** | Per Channel | Indicates the existence/non-existence of flow that may enter the specified channel from another channel. If the other channel has a higher rate of change than the specified channel, then the product may not end up becoming coherent if left to its own devices. A good example of this is: A branch that applies to Release has a subscription to Arcade (on .NET Tools - Latest) that is set to update every day. Because branches applying to the release channel and arcade's master branch have different check-in policies during release shutdown time (arcade has a lower bar), it's likely that the arcade subscription will continue to generate changes on the release channel, potentially putting coherency at risk. The subscription causing cross-channel flow should be disabled or have its update rate set to "none".  | 
| **Missing Product Input Subscriptions** | Per Repo, Per Default Channel (input branch) | Indicates that a branch that applies to a default channel is missing inputs subscriptions for product dependencies, and thus coherency may not be able to be achieved. A subscription is not missing when dependencies are pinned or when they are tied via CoherentParentDependency attributes to other dependencies. |
| **Missing Toolset Input Subscriptions** | Per Repo, Per Default Channel (input branch) | Indicates that a branch that applies to a default channel is missing inputs subscriptions for toolset dependencies. A subscription is not missing when dependencies are pinned or when they are tied via CoherentParentDependency attributes to other dependencies. |
| **Time to Coherency** | Per Repo, Per default output channel | Time to coherency is an aggregated metric indicating that, if non-dependnecy flow changes were halted for all branches that apply by default to the specified channel, how long would it take for coherency to be acheived. It is possible for this value to be infinite if there are cycles that flow automatically. This metric is not static and is instead based on the current dependency graph state at the current node. This metric needs to take into account all of the times at the specified steps in the dependency flow process: official build time, release pipeline execution time, dependency flow graph shape, dependency update pr elapsed time, etc. |