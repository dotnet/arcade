on:
  workflow_call:
    inputs:
      pr_title_template:
        description: 'The template used for the PR title. Special placeholder tokens that will be replaced with a value: %target_branch%, %source_pr_title%, %source_pr_number%, %source_pr_author%, %cc_users%.'
        required: false
        type: string
        default: '[%target_branch%] %source_pr_title%'
      pr_description_template:
        description: 'The template used for the PR description. Special placeholder tokens that will be replaced with a value: %target_branch%, %source_pr_title%, %source_pr_number%, %source_pr_author%, %cc_users%.'
        required: false
        type: string
        default: |
          Backport of #%source_pr_number% to %target_branch%

          /cc %cc_users%
      repository_owners:
        description: 'A comma-separated list of repository owners where the workflow will run. Defaults to "dotnet,microsoft".'
        required: false
        type: string
        default: 'dotnet,microsoft'
      additional_git_am_switches:
        description: 'Additional switches to pass to git am command (e.g., "--exclude=docs/release-notes/* --whitespace=fix"). Useful for excluding files that differ between branches or fixing whitespace conflicts.'
        required: false
        type: string
        default: ''
      conflict_resolution_command:
        description: >-
          Optional shell command to attempt automatic conflict resolution after a failed git am.
          If the command eliminates merge conflicts, the backport proceeds automatically.
          Do not run git commands from this parameter as they might have unintended side effects.
          DO NOT PASS UNTRUSTED INPUT TO THIS PARAMETER.
        required: false
        type: string

jobs:
  cleanup:
    uses: dotnet/arcade/.github/workflows/scheduled-action-cleanup-base.yml@main
    with:
      repository_owners: ${{ inputs.repository_owners }}

  run_backport:
    if: ${{ contains(format('{0},', inputs.repository_owners), format('{0},', github.repository_owner)) && github.event.issue.pull_request != '' && contains(github.event.comment.body, '/backport to') }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
    - name: Extract backport target branch
      uses: actions/github-script@v7
      id: target-branch-extractor
      with:
        result-encoding: string
        script: |
          if (context.eventName !== "issue_comment") throw "Error: This action only works on issue_comment events.";

          // extract the target branch name from the trigger phrase containing these characters: a-z, A-Z, digits, forward slash, dot, hyphen, underscore
          const regex = /^\/backport to ([a-zA-Z\d\/\.\-\_]+)/;
          target_branch = regex.exec(context.payload.comment.body);
          if (target_branch == null) throw "Error: No backport branch found in the trigger phrase.";

          return target_branch[1];
    - name: Unlock comments if PR is locked
      uses: actions/github-script@v7
      if: ${{ github.event.issue.locked == true }}
      with:
        script: |
          console.log(`Unlocking locked PR #${context.issue.number}.`);
          await github.rest.issues.unlock({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
    - name: Post backport started comment to pull request
      uses: actions/github-script@v7
      with:
        script: |
          const target_branch = '${{ steps.target-branch-extractor.outputs.result }}';
          const workflow_run_url = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
          const backport_start_body = `Started backporting to \`${target_branch}\` ([link to workflow run](${workflow_run_url}))`;
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: backport_start_body
          });
    - name: Checkout repo
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Run backport
      uses: actions/github-script@v7
      env:
        BACKPORT_PR_TITLE_TEMPLATE: ${{ inputs.pr_title_template }}
        BACKPORT_PR_DESCRIPTION_TEMPLATE: ${{ inputs.pr_description_template }}
        ADDITIONAL_GIT_AM_SWITCHES: ${{ inputs.additional_git_am_switches }}
        CONFLICT_RESOLUTION_COMMAND: ${{ inputs.conflict_resolution_command }}
      with:
        script: |
          const target_branch = '${{ steps.target-branch-extractor.outputs.result }}';
          const repo_owner = context.payload.repository.owner.login;
          const repo_name = context.payload.repository.name;
          const pr_number = context.payload.issue.number;
          const comment_user = context.payload.comment.user.login;
          const workflow_run_url = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

          const wrap_in_code_block = (language, content) => `\`\`\`${language}\n${content}\n\`\`\``;
          const wrap_in_details_block = (summary, content) => `<details>\n<summary>${summary}</summary>\n\n${content}\n</details>`;

          // Post a comment on the PR and return the comment URL
          async function postComment(body) {
            const { data: comment } = await github.rest.issues.createComment({
              owner: repo_owner,
              repo: repo_name,
              issue_number: pr_number,
              body
            });
            return comment.html_url;
          }

          try {
            // verify the comment user has write access to the repo
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: repo_owner,
                repo: repo_name,
                username: comment_user
              });

              const writePermissions = ['admin', 'write'];
              if (!writePermissions.includes(permission.permission)) {
                throw new Error(`Insufficient permissions: ${permission.permission}`);
              }

              console.log(`Verified ${comment_user} has ${permission.permission} access to the repo.`);
            } catch (error) {
              console.log(error);
              throw new Error(`Error: @${comment_user} does not have write access to this repo, backporting is not allowed. Required permissions: write or admin.`);
            }

            try { await exec.exec(`git ls-remote --exit-code --heads origin ${target_branch}`) } catch { throw new Error(`Error: The specified backport target branch "${target_branch}" wasn't found in the repo.`); }
            console.log(`Backport target branch: ${target_branch}`);

            console.log("Applying backport patch");

            await exec.exec(`git checkout ${target_branch}`);
            await exec.exec(`git clean -xdff`);

            // configure git
            await exec.exec(`git config user.name "github-actions"`);
            await exec.exec(`git config user.email "github-actions@github.com"`);

            // create temporary backport branch
            const temp_branch = `backport/pr-${pr_number}-to-${target_branch}`;
            await exec.exec(`git checkout -b ${temp_branch}`);

            // skip opening PR if the branch already exists on the origin remote since that means it was opened
            // by an earlier backport and force pushing to the branch updates the existing PR
            let should_open_pull_request = true;
            try {
              await exec.exec(`git ls-remote --exit-code --heads origin ${temp_branch}`);
              should_open_pull_request = false;
            } catch { }

            // download and apply patch
            const patch_file = 'changes.patch';
            await exec.exec(`curl -sSL "${context.payload.issue.pull_request.patch_url}" --output ${patch_file}`);

            const additional_switches = process.env.ADDITIONAL_GIT_AM_SWITCHES?.trim() || '';
            const base_switches = '--3way --empty=keep --ignore-whitespace --keep-non-patch';
            const git_am_command = additional_switches
              ? `git am ${base_switches} ${additional_switches} ${patch_file}`
              : `git am ${base_switches} ${patch_file}`;
            let git_am_output = `$ ${git_am_command}\n\n`;
            let git_am_failed = false;
            try {
              await exec.exec(git_am_command, [], {
                listeners: {
                  stdout: function stdout(data) { git_am_output += data; },
                  stderr: function stderr(data) { git_am_output += data; }
                }
              });
            } catch (error) {
              git_am_output += error;
              git_am_failed = true;
            }

            if (git_am_failed) {
              const resolution_command = process.env.CONFLICT_RESOLUTION_COMMAND || '';

              // If no resolution command supplied, fail immediately
              if (resolution_command.trim().length === 0) {
                const details = `${wrap_in_code_block('console', git_am_output)}\n[Link to workflow output](${workflow_run_url})`;
                const git_am_failed_body = `@${comment_user} backporting to \`${target_branch}\` failed, the patch most likely resulted in conflicts. Please backport manually!\n${wrap_in_details_block('git am output', details)}`;
                postComment(git_am_failed_body);
                core.setFailed("git am failed, most likely due to a merge conflict.");
                return;
              }

              console.log(`git am failed; attempting in-session conflict resolution via provided command: ${resolution_command}`);

              // Run user-provided resolution command
              // Ignore return code to capture stdout/stderr
              const resolution_result = await exec.getExecOutput(`bash -c "${resolution_command}"`, [], { ignoreReturnCode: true });
              if (resolution_result.exitCode !== 0) {
                const details = `\`${resolution_command}\` stderr:\n${wrap_in_code_block('console', resolution_result.stderr)}\n[Link to workflow output](${workflow_run_url})`;
                const resolution_failed_body = `@${comment_user} backporting to \`${target_branch}\` failed during automated conflict resolution. Please backport manually!\n${wrap_in_details_block('Error details', details)}`;
                postComment(resolution_failed_body);
                core.setFailed(`Automated conflict resolution command exited with code ${resolution_result.exitCode}`);
                return;
              }

              // Stage changes (excluding patch file)
              await exec.exec(`git add -A`);
              await exec.exec(`git reset HEAD ${patch_file}`);

              // Check for remaining conflicts
              const diff_command = 'git diff --name-only --diff-filter=U';
              const diff_result = await exec.getExecOutput(diff_command);
              if (diff_result.stdout.trim().length !== 0) {
                const details = `${wrap_in_code_block('console', diff_result.stdout)}\n[Link to workflow output](${workflow_run_url})`;
                const conflicts_body = `@${comment_user} backporting to \`${target_branch}\` failed. Automated conflict resolution did not resolve all conflicts. Please backport manually!\n${wrap_in_details_block(`${diff_command} output`, details)}`;
                postComment(conflicts_body);
                core.setFailed(`Automated conflict resolution did not resolve all conflicts.`);
                return;
              }

              console.log('Automated conflict resolution resolved all merge conflicts. Continuing.');
              await exec.exec('git am --continue');
            }

            // push the temp branch to the repository
            await exec.exec(`git push --force --set-upstream origin HEAD:${temp_branch}`);

            if (!should_open_pull_request) {
              console.log("Backport temp branch already exists, skipping opening a PR.");
              return;
            }

            // prepare the GitHub PR details

            // get users to cc (append PR author if different from user who issued the backport command)
            let cc_users = `@${comment_user}`;
            if (comment_user != context.payload.issue.user.login) cc_users += ` @${context.payload.issue.user.login}`;

            // replace the special placeholder tokens with values
            const { BACKPORT_PR_TITLE_TEMPLATE, BACKPORT_PR_DESCRIPTION_TEMPLATE } = process.env

            const backport_pr_title = BACKPORT_PR_TITLE_TEMPLATE
              .replace(/%target_branch%/g, target_branch)
              .replace(/%source_pr_title%/g, context.payload.issue.title)
              .replace(/%source_pr_number%/g, context.payload.issue.number)
              .replace(/%source_pr_author%/g, context.payload.issue.user.login)
              .replace(/%cc_users%/g, cc_users);

            const backport_pr_description = BACKPORT_PR_DESCRIPTION_TEMPLATE
              .replace(/%target_branch%/g, target_branch)
              .replace(/%source_pr_title%/g, context.payload.issue.title)
              .replace(/%source_pr_number%/g, context.payload.issue.number)
              .replace(/%source_pr_author%/g, context.payload.issue.user.login)
              .replace(/%cc_users%/g, cc_users);

            // open the GitHub PR
            await github.rest.pulls.create({
              owner: repo_owner,
              repo: repo_name,
              title: backport_pr_title,
              body: backport_pr_description,
              head: temp_branch,
              base: target_branch
            });

            console.log("Successfully opened the GitHub PR.");
          } catch (error) {
            const body = `@${comment_user} an error occurred while backporting to \`${target_branch}\`. See the [workflow output](${workflow_run_url}) for details.`;
            const comment_url = await postComment(body);
            console.log(`Posted comment: ${comment_url}`);
            core.setFailed(error);
          }

    - name: Re-lock PR comments
      uses: actions/github-script@v7
      if: ${{ github.event.issue.locked == true && (success() || failure()) }}
      with:
        script: |
          console.log(`Locking previously locked PR #${context.issue.number} again.`);
          await github.rest.issues.lock({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            lock_reason: "resolved"
          });
