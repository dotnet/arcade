# Microsoft.DotNet.SharedFramework.Sdk

This package provides a common set of tools for authoring framework packs, shared frameworks, and packages and installers for packs and frameworks.

## Building Framework Packs

This SDK supports building framework packs based on the [official design](https://github.com/dotnet/designs/blob/master/accepted/2019/targeting-packs-and-runtime-packs.md) as well as additional extensions such as profiles and single-file support. To define a shared framework project, create a project with the `.sfxproj` suffix that references both the `Microsoft.NET.Sdk` and `Microsoft.DotNet.SharedFramework.Sdk` SDKs and defines the name in the `SharedFrameworkName` property and the pack type in the `PlatformPackageType` property.

An example project is included below:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <Sdk Name="Microsoft.DotNet.SharedFramework.Sdk" />
  <PropertyGroup>
     <!-- Required properties -->
    <TargetFramework>netcoreapp3.0</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SharedFrameworkName>Microsoft.Banana.App</SharedFrameworkName>
    <PlatformPackageType>RuntimePack</PlatformPackageType>
    <DisableImplicitFrameworkReferences>true</DisableImplicitFrameworkReferences>
  </PropertyGroup>
  
  <ItemGroup>
    <FrameworkReference Include="Microsoft.NETCore.App" RuntimeFrameworkVersion="3.0.0" />
    
    <ProjectReference Include="..\..\MyAssembly1\MyAssembly1.csproj" />
    <ProjectReference Include="..\..\MyAssembly2\MyAssembly2.csproj" />
    <PackageReference Include="Foo" Version="1.0.4" />
    
    <NativeRuntimeAsset Include="linux-x64/libmydep.so" Condition=" '$(RuntimeIdentifier)' == 'linux-x64' " />
  </ItemGroup>
  
</Project>
```

This example project shows some of the basic options provided by the SDK. The `SharedFrameworkName` property specifies the name of the shared framework. This is used to determine the NuGet package ID as well as appearing in various data files generated by the build. The `PlatformPackageType` property specifies the type of pack the project defines. There are four types of packs this SDK supports:

- `RuntimePack`: RID-specific runtime packages
- `TargetingPack`: Packs of reference assemblies
- `AppHostPack`: Pack containing the app hosts
- `ToolPack`: This pack option allows you to have completely custom scripting for what files are included where in your pack. It also enables creating installer-only projects with this SDK.

This SDK uses the standard mechanisms in the .NET SDK for referencing packages, projects, and other frameworks to resolve its dependencies and collect the files that are a part of the pack. To include native files, add them to the `NativeRuntimeAsset` item group.

If you need to resolve additional managed assemblies, you can add them to the `ReferenceCopyLocalPaths` item group for runtime packs or `ReferencePath` for targeting packs. XML documentation files can be added to the `DocFilesToPackage` item group. If you need to resolve your assemblies in a target, you can define your own target to resolve them. To enable these files to have ReadyToRun code generated for them for a runtime pack, update the `GetSharedFrameworkFilesForReadyToRunDependsOn` property to include your targets in a semicolon-delimited list. If you are adding additional files to a targeting pack, add `BeforeTargets="GetFilesToPackage"` to the target definition.

### Platform Manifest generation

Since platform manifest generation can be tricky at times when a shared framework has differing files per platform, this SDK provides two different mechanisms for generating a platform manifest, templating or harvesting.

Pros of harvesting:

- Simple declaration in the project file.
  - You define a property in the targeting pack project that points to the runtime pack project. The SDK will determine all of the files that the runtime pack project produces on RIDs that this build will produce.
- Less friction when adding files to the manifest.
  - Files will be automatically added by the harvesting process.

Cons of harvesting:

- Either all runtime pack RIDs must be buildable from a single invocation or one RID must have a superset of all files in the targeting pack.

Pros of templating:

- All files can be declared to be in the manifest without needing every file on disk.
- Targeting pack can be built independently of the runtime pack.
- Ensures that every file in a runtime pack is a known file in the manifest.

Cons of templating:

- Each file has to be declared with an MSBuild item.
- File and assembly fallback versions need to be declared for files that do not exist in the targeting pack.
- Any change in the list of files requires a new MSBuild item declaring the entry.

### Platform Manifest Harvesting

For platforms where all target platforms have the same files
or where one platform has a superset of the files available
on all platforms, we can generate a platform manifest from
the present files in the runtime pack.

This is enabled by default or when `UseTemplatedPlatformManifest` is not set to `true`.

Set the `RuntimePackProjectPath` to the path to the runtime pack shared framework project.

If you only want to use one RID to generate the platform manifest, you can set
the `RuntimePackPlatformForManifest` property to the RID you'd like to use.
If the chosen RID doesn't have a superset of files for all shipping platforms,
then you may have unexpected behavior when using the produced targeting pack.

### Templated Platform Manifest

For shared frameworks with differing sets of files on various platforms
and with no single platform that contains all of the files, this SDK provides support
for creating a platform manifest from a templated list of items.

Assumptions:

- All managed assemblies are either present in both the ref and runtime pack for the shared framework
    or have an easily calculatable assembly version and file version.
- All native files have an easily calculatable file version.

To use, set `UseTemplatedPlatformManifes`t to true and define a set of `PlatformManifestFileEntry` items

`PlatformManifestFileEntry` metadata:

- `ItemSpec`/`Identity`
  - File name and extension of file in the shared framework.
- `IsNative`
  - true when the file is a native file
- `FallbackAssemblyVersion`
  - An assembly version for this file if it is not present in the ref-pack build.
- `FallbackFileVersion`
  - A file version for this file if it is not present in the ref-pack build.

Properties for these targets:
`UseTemplatedPlatformManifest`: Set to true to enable the templated platform manifest generation
`PlatformManifestFallbackAssemblyVersion`: Fallback asssembly version when one is needed and there is no fallback on the entry.
`PlatformManifestFallbackFileVersion`: Fallback file version when one is needed and there is no fallback on the entry.

### RuntimeList/FrameworkList Generation

The FrameworkList/RuntimeList support in this SDK has some additions on the base design to support profile and single-file features.

If your shared framework has various profiles, you can use `<FrameworkListFileClass>` items to specify the profiles for each file in the shared framework. However, once you've specified one `FrameworkListFileClass` entry, you need to specify one for every file in the framework.

If your shared framework can drop some files from the single-file bundle, you can specify `<SingleFileHostIncludeFilename>` items that specify which files by name are **included** in the single file bundle. Once one `SingleFileHostIncludeFilename` item is specified, all files without corresponding `SingleFileHostIncludeFilename` elements will be marked as droppable from a single file build.

The name of the framework/runtime is specified in the `SharedFrameworkFriendlyName` property, which defaults to the value of `SharedFrameworkName`.

### Archives

By default, this SDK also generates an archive that can be extracted on top of an existing .NET SDK or Runtime layout. The name of this file is derived from the `SharedFrameworkArchiveName` property and the RID. By default, `SharedFrameworkArchiveName` is set to the value of `SharedFrameworkName`.

### Custom dumping to disk

This SDK provides a custom target named `PublishSharedFrameworkToDisk` that publishes the generated framework pack to disk as though the folder specified via the `SharedFrameworkOutputPath` is the root of a .NET SDK or Runtime layout. This target is used internally by the archive and installer generation. Additionally, if you are defining a custom installer project that doesn't use the `.sfxproj` extension (for example if you only need installers and not NuGet packages), you can define your own `PublishSharedFrameworkToDisk` target that publishes your files to disk in the correct layout for the installers to place files in during installation.

## Building Installers

In addition to producing framework packs this SDK also supports generating installers for the shared framework in .msi, .deb, .rpm, and .pkg formats. This support is opt-in by setting the `GenerateInstallers` property to `true`. In addition, to enable the .deb and .rpm support, the `GenerateDebPackage` and `GenerateRpmPackage` properties respectively need to be set to true. This support acts independently of the shared framework support and only depends on the `PublishSharedFrameworkToDisk` target. So, you can use the SDK with a project that has a non-`.sfxproj` extension such as `.proj` or `.installproj` and set `GenerateInstallers` to `true` to opt into only installer generation, as long as you define the `PublishSharedFrameworkToDisk` target.

There are a few common properties used by all of the installer types and the bundle installers (documented after the installers):

- `SharedFrameworkInstallerName`
  - The name of the installer file without an extension. This defaults to `SharedFrameworkArchiveName`.
- `ProductBrandPrefix`
  - The branding name of this component, such as "Microsoft Windows Desktop"
- `PackageBrandNameSuffix` (`ToolPack` installers only)
  - The type of package, for example "Shared Host" or "AppHost Pack". This is set automatically for any non-ToolPack package types.

For correct branding and versioning, this SDK has a dependency on Arcade's versioning setup, including the `MajorVersion`, `MinorVersion`, `PreReleaseVersionLabel`, `PreReleaseVersionIteration` and `DotNetFinalVersionKind` properties.

Since some framework packs do not use `RuntimeIdentifier`s in their build, for example targeting packs, for the installer build you can define `InstallerRuntimeIdentifiers` and the build will fan out for the installer build across those target RIDs. In addition, the `InstallerRuntimeIdentifier` property will default to the value of `RuntimeIdentifier` if it is not set.

### Wix MSI configuration

If you have files that need to have a stabilized identity in the MSI file, you can add items to the `HeatOutputFileElementToStabilize` item group. Each item in this group specifies a unique suffix of a path (enough to identify a single file) and a value for the `ReplacementId` metadata as the id to set in the MSI for this file.

If you want to create MSIs for the target RID that target other architecture install locations, you can add `CrossArchSdkMsiInstallerArch` items for all of the target architecture install locations you want to generate installers of the current build for.

### Linux package configuration

To add package dependencies for linux packages, add a `LinuxPackageDependency` item with the version in the `Version` metadata.

#### Deb package configuration

To add additional properties for the deb package tool, add items to the `DebJsonProperty` item group.

#### Rpm package configuration

To add additional properties for the deb package tool, add items to the `RpmJsonProperty` item group.

### MacOS Pkg configuration

To specify a directory where `pkgbuild` should look for scripts, set the `MacOSScriptsDirectory` to the path to the scripts.

If you are building a `ToolPack` pack, you need to specify the `MacOSComponentNamePackType` property to create the component name for the `.pkg` package. If you want the component name to not include the version (for example you are building the shared host), you can set the `IncludeVersionInMacOSComponentName` property to false.

If your `pkg` is later going to be bundled in a macOS `pkg` bundle created by `productbuild`, you should also specify the `MacOSPackageDescription` property, which will set the package description in the bundle distribution file.

### Visual Studio Insertion Package configuration

Visual Studio insertion packages generated by the SDK are named in the form `VS.Redist.Common.$(VSInsertionShortComponentName).$(InstallerTargetArchitecture)$(CrossArchContentsBuildPart).$(MajorVersion).$(MinorVersion)`

The `InstallerTargetArchitecture` and later properties are automatically calculated by the SDK or are version properties. You are required to provide the `VSInsertionShortComponentName` property value yourself.

## Building Installer Bundles

As part of the installer support, the SDK supports building Wix bundle installers and macOS pkg bundles. These bundles are defined in a separate project with a `.bundleproj` extension that includes the .NET SDK and this SDK as shown in the example project.

### Wix Bundle configuration

### MacOS Pkg bundle configuration