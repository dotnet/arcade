<Project>
  <PropertyGroup>
    <PackageLicenseFile Condition="'$(PackageLicenseExpression)' == ''">$([System.IO.Path]::GetFileName('$(LicenseFile)'))</PackageLicenseFile>
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
    <PublishReadyToRun Condition="'$(PublishReadyToRun)' == '' and '$(PlatformPackageType)' == 'RuntimePack' and '$(Configuration)' == 'Release'">true</PublishReadyToRun>
    <!-- For .NET 6 and higher, default to using Crossgen2 in non-composite mode if PublishReadyToRun == true -->
    <PublishReadyToRunUseCrossgen2 Condition="'$(PublishReadyToRunUseCrossgen2)' == '' and '$(PublishReadyToRun)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' >= '6.0'">true</PublishReadyToRunUseCrossgen2>
    <PublishReadyToRunEmitSymbols>true</PublishReadyToRunEmitSymbols>
    <PublishReadyToRunShowWarnings>true</PublishReadyToRunShowWarnings>
    <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>$(AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder);.map;.r2rmap;.dbg;.debug;.dwarf</AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>
    <_DefaultHostJsonTargetPath>runtimes/$(RuntimeIdentifier)/lib/$(TargetFramework)</_DefaultHostJsonTargetPath>
    <HostJsonTargetPath Condition="'$(HostJsonTargetPath)' == ''">$(_DefaultHostJsonTargetPath)</HostJsonTargetPath>
    <IncludeFallbacksInDepsFile Condition="'$(IncludeFallbacksInDepsFile)' == ''">false</IncludeFallbacksInDepsFile>
  </PropertyGroup>


  <!--
    Enable Self-Contained for FrameworkReference resolution to enable resolving runtime pack assets.
    (used in package verification)
  -->
  <Target Name="_ConsiderSelfContainedForFrameworkReferenceResolution" BeforeTargets="ProcessFrameworkReferences">
    <PropertyGroup>
      <SelfContained>true</SelfContained>
    </PropertyGroup>
  </Target>


  <Target Name="_RemoveSelfContainedAfterFrameworkReferenceResolution" AfterTargets="ProcessFrameworkReferences">
    <PropertyGroup>
      <SelfContained>false</SelfContained>
    </PropertyGroup>
  </Target>

  <Target Name="GetSharedFrameworkFilesForReadyToRun" DependsOnTargets="$(GetSharedFrameworkFilesForReadyToRunDependsOn)" Returns="@(ReferenceCopyLocalPaths)" />

  <ItemDefinitionGroup>
    <_SymbolFilesToPackage>
      <IsSymbolFile>true</IsSymbolFile>
    </_SymbolFilesToPackage>
  </ItemDefinitionGroup>

  <Target Name="_FindSymbolFilesForSharedFrameworkFiles"
          DependsOnTargets="GetSharedFrameworkFilesForReadyToRun"
          Returns="@(_SymbolFilesToPackage)">
    <ItemGroup>
      <_SymbolFilesToPackage Include="@(ReferenceCopyLocalPaths->'%(RootDir)%(Directory)%(FileName).pdb')" Exclude="@(RuntimePackAsset)" />
      <_SymbolFilesToPackage Include="@(ReferenceCopyLocalPaths->'%(RootDir)%(Directory)%(FileName)%(Extension).dbg')" Exclude="@(RuntimePackAsset)" />
      <_SymbolFilesToPackage Include="@(ReferenceCopyLocalPaths->'%(RootDir)%(Directory)%(FileName)%(Extension).dwarf')" Exclude="@(RuntimePackAsset)" />
      <_SymbolFilesToPackage Remove="@(_SymbolFilesToPackage)" Condition="!Exists('%(Identity)')" />
    </ItemGroup>
  </Target>

  <Target Name="_PrepareSharedFrameworkForReadyToRun"
          DependsOnTargets="_CalculatePackageInformation;
                            GetSharedFrameworkFilesForReadyToRun"
          Condition="'$(PlatformPackageType)' == 'RuntimePack'">
    <ItemGroup>
      <ResolvedFileToPublish Include="@(RuntimePackAsset)" ReferenceOnly="true" PostprocessAssembly="true" RelativePath="%(FileName)%(Extension)" />
      <ResolvedFileToPublish Include="@(ReferenceCopyLocalPaths)" Exclude="@(RuntimePackAsset)" PostprocessAssembly="true" RelativePath="%(FileName)%(Extension)" />
    </ItemGroup>
    <!--
      The PrepareForReadyToRunCompilation task now requires the MainAssembly metadata to be set.
      It's only used in composite mode, which we do not use, so create a ficticous $(PackageId).dll
      to ensure we don't accidentally trigger any unexpected behavior.
    -->
    <ItemGroup Condition="'@(IntermediateAssembly)' == ''">
      <IntermediateAssembly Include="$(IntermediateOutputPath)/$(PackageId).dll" />
    </ItemGroup>
  </Target>

  <Target Name="_ReadyToRunSharedFramework"
          DependsOnTargets="_PrepareSharedFrameworkForReadyToRun;CreateReadyToRunImages"
          Condition="'$(PlatformPackageType)' == 'RuntimePack'">
    <ItemGroup>
      <IntermediateAssembly Remove="@(IntermediateAssembly)" />
      <FilesToPackage Remove="@(FilesToPackage)" />
      <FilesToPackage Include="@(ResolvedFileToPublish)" Exclude="@(RuntimePackAsset)" />
      <FilesToPackage Condition="'%(FilesToPackage.AssetType)' == 'native'" IsNative="true" />
      <_r2rSymbolFiles Include="@(ResolvedFileToPublish->'%(RootDir)%(Directory)%(FileName).ni.pdb')" />
      <!-- This accounts for perfmaps generated by crossgen2 when specifying perfmap-format-version:1, which is the new default. -->
      <_r2rV1MapFiles Include="@(ResolvedFileToPublish->'%(RootDir)%(Directory)%(FileName).ni.r2rmap')" />
    </ItemGroup>
    <!-- MSBuild does not resolve globs from item transformations,
         so round-trip through a property to activate glob resolution. -->
    <PropertyGroup>
      <!-- This accounts for legagy-named perfmaps generated by crossgen2 when specifying perfmap-format-version:0. -->
      <_r2rSymbolFilePattern>@(ResolvedFileToPublish->'%(RootDir)%(Directory)%(FileName).ni.*.map')</_r2rSymbolFilePattern>
    </PropertyGroup>
    <ItemGroup>
      <FilesToPackage Include="@(_r2rSymbolFiles)" Condition="Exists('%(Identity)')" IsSymbolFile="true" />
      <FilesToPackage Include="$(_r2rSymbolFilePattern)" IsSymbolFile="true" />
      <FilesToPackage Include="@(_r2rV1MapFiles)" Condition="Exists('%(Identity)')" IsSymbolFile="true" />
    </ItemGroup>
  </Target>

  <Target Name="GetFilesToPackage"
          DependsOnTargets="_CalculatePackageInformation;
                            ResolveFrameworkReferences;
                            ResolveLockFileCopyLocalFiles;
                            ResolveReferences;
                            _ReadyToRunSharedFramework;
                            _FindSymbolFilesForSharedFrameworkFiles"
          Returns="@(FilesToPackage)">
    <ItemGroup>
      <FilesToPackage Include="@(_SymbolFilesToPackage)" IsSymbolFile="true" />
      <FilesToPackage Include="@(NativeRuntimeAsset)" IsNative="true" />
    </ItemGroup>
    <ItemGroup Condition="'$(PlatformPackageType)' == 'RuntimePack' or '$(PlatformPackageType)' == 'AppHostPack'">
      <!---
       Files for runtime packs will have already been added to FilesToPackage in _ReadyToRunSharedFramework.
       Files for AppHost packs have to be added manually anyway before this target.
      -->
      <FilesToPackage Condition="'%(FilesToPackage.TargetPath)' == ''">
        <TargetPath Condition="'%(FilesToPackage.IsNative)' != 'true'">runtimes/$(RuntimeIdentifier)/lib/$(TargetFramework)</TargetPath>
        <TargetPath Condition="'%(FilesToPackage.IsNative)' == 'true'">runtimes/$(RuntimeIdentifier)/native</TargetPath>
      </FilesToPackage>
      <FilesToPackage Condition="'%(FilesToPackage.DestinationSubDirectory)' != ''">
        <TargetPath>%(FilesToPackage.TargetPath)/%(FilesToPackage.DestinationSubDirectory)</TargetPath>
      </FilesToPackage>
    </ItemGroup>

    <ItemGroup Condition="'$(PlatformPackageType)' == 'TargetingPack'">
      <FilesToPackage Include="@(ReferencePath)" Condition="'%(ReferencePath.FrameworkReferenceName)' == ''">
        <TargetPath>ref/$(TargetFramework)</TargetPath>
      </FilesToPackage>

      <!-- include all doc files -->
      <DocFilesToPackage Include="%(FilesToPackage.RootDir)%(FilesToPackage.Directory)**\%(FilesToPackage.FileName).xml" />

      <FilesToPackage Include="@(DocFilesToPackage)">
        <TargetPath>ref/$(TargetFramework)/%(RecursiveDir)</TargetPath>
      </FilesToPackage>
    </ItemGroup>

    <ItemGroup>
      <FilesToPackage Condition="'%(Extension)' == '.pdb' or '%(Extension)' == '.dbg' or '%(Extension)' == '.dwarf'">
        <IsSymbolFile>true</IsSymbolFile>
      </FilesToPackage>
      <FilesToPackage Condition="'%(Extension)' == '.mibc'">
        <IsPgoData>true</IsPgoData>
        <TargetPath>PgoData</TargetPath>
      </FilesToPackage>
      <!-- Legacy crossgen perf map files. Supported by crossgen2 using perfmap-format-version:0. -->
      <FilesToPackage Condition="$([System.String]::new('%(Filename)').Contains('.ni.{')) and
                                 $([System.String]::new('%(Filename)').EndsWith('}')) and
                                 '%(Extension)' == '.map'">
        <IsSymbolFile>true</IsSymbolFile>
      </FilesToPackage>
      <!-- crossgen2 v1 perf map files. -->
      <FilesToPackage Condition="'%(Extension)' == '.r2rmap'">
        <IsSymbolFile>true</IsSymbolFile>
      </FilesToPackage>
    </ItemGroup>

    <ItemGroup Condition="'$(PlatformPackageType)' == 'TargetingPack'">
      <!-- Targeting packs don't have symbol files. -->
      <FilesToPackage Remove="@(FilesToPackage)" Condition="'%(FilesToPackage.IsSymbolFile)' == 'true'" />
    </ItemGroup>

    <ItemGroup>
      <FilesToPackage Include="$(LicenseFile)" GeneratedBuildFile="true" TargetPath="" />
    </ItemGroup>

    <RemoveDuplicates Inputs="@(FilesToPackage)">
      <Output TaskParameter="Filtered" ItemName="_FilteredFilesToPackage" />
    </RemoveDuplicates>

    <ItemGroup>
      <FilesToPackage Remove="@(FilesToPackage)" />
      <FilesToPackage Include="@(_FilteredFilesToPackage)" />
    </ItemGroup>
  </Target>

  <UsingTask TaskName="GenerateSharedFrameworkDepsFile" AssemblyFile="$(DotNetSharedFrameworkTaskFile)" />
  <Target Name="_GenerateSharedFrameworkDepsFile"
          DependsOnTargets="GetFilesToPackage"
          Condition="'$(PlatformPackageType)' == 'RuntimePack'">
    <PropertyGroup>
      <_TargetRootForFilesForDepsFile Condition="'$(HostJsonTargetPath)' == '$(_DefaultHostJsonTargetPath)'">runtimes/$(RuntimeIdentifier)</_TargetRootForFilesForDepsFile>
      <_TargetRootForFilesForDepsFile Condition="'$(HostJsonTargetPath)' != '$(_DefaultHostJsonTargetPath)'">$(HostJsonTargetPath)</_TargetRootForFilesForDepsFile>
    </PropertyGroup>
    <ItemGroup>
      <_FilesForDepsFile Include="@(FilesToPackage)"
                         Condition="'%(FilesToPackage.IsSymbolFile)' != 'true' and
                                    '%(FilesToPackage.PackOnly)' != 'true' and
                                    '%(FilesToPackage.ExcludeFromDataFiles)' != 'true' and
                                    $([System.String]::new('%(FilesToPackage.TargetPath)').StartsWith('$(_TargetRootForFilesForDepsFile)'))" />
    </ItemGroup>
    <GenerateSharedFrameworkDepsFile TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
                                     RuntimeIdentifier="$(RuntimeIdentifier)"
                                     SharedFrameworkName="$(SharedFrameworkName)"
                                     SharedFrameworkPackName="$(PackageId)"
                                     Version="$(Version)"
                                     Files="@(_FilesForDepsFile)"
                                     IntermediateOutputPath="$(IntermediateOutputPath)"
                                     SharedFrameworkDepsNameOverride="$(SharedFrameworkHostFileNameOverride)"
                                     RuntimeIdentifierGraph="$(BundledRuntimeIdentifierGraphFile)"
                                     IncludeFallbacksInDepsFile="$(IncludeFallbacksInDepsFile)">
      <Output TaskParameter="GeneratedDepsFile" ItemName="_SharedFrameworkDepsFile" />
    </GenerateSharedFrameworkDepsFile>
    <ItemGroup>
      <_SharedFrameworkDepsFile>
        <TargetPath>$(HostJsonTargetPath)</TargetPath>
        <GeneratedBuildFile>true</GeneratedBuildFile>
      </_SharedFrameworkDepsFile>
      <FileWrites Include="@(_SharedFrameworkDepsFile)" />
      <FilesToPackage Include="@(_SharedFrameworkDepsFile)" />
    </ItemGroup>
  </Target>

  <Target Name="_PrepareForRuntimeConfig" Condition="'$(PlatformPackageType)' == 'RuntimePack'">
    <PropertyGroup>
      <GenerateRuntimeConfigurationFiles>true</GenerateRuntimeConfigurationFiles>
      <ProjectRuntimeConfigDevFilePath></ProjectRuntimeConfigDevFilePath>
      <ProjectRuntimeConfigFilePath>$(IntermediateOutputPath)$(SharedFrameworkName).runtimeconfig.json</ProjectRuntimeConfigFilePath>
      <ProjectRuntimeConfigFilePath Condition="'$(SharedFrameworkHostFileNameOverride)' != ''">$(IntermediateOutputPath)$(SharedFrameworkHostFileNameOverride).runtimeconfig.json</ProjectRuntimeConfigFilePath>
    </PropertyGroup>
  </Target>

  <Target Name="_GenerateSharedFrameworkRuntimeConfigFile"
          DependsOnTargets="ResolveReferences;_PrepareForRuntimeConfig;GenerateBuildRuntimeConfigurationFiles"
          Condition="'$(PlatformPackageType)' == 'RuntimePack'">
    <ItemGroup>
      <FilesToPackage Include="$(ProjectRuntimeConfigFilePath)"
                     TargetPath="$(HostJsonTargetPath)"
                     GeneratedBuildFile="true" />
    </ItemGroup>
  </Target>

  <Target Name="_GetPackagedFileNamesNoDuplicates"
          DependsOnTargets="GetFilesToPackage"
          Returns="@(_PackagedFileNamesFiltered)">
    <ItemGroup>
      <!-- We don't include debug files in the platform manifest
           since they aren't shipped in the package nor do they
           participate in reference resolution.
           We also don't want to include generated json files since they're not included in reference resolution.-->
      <_PackagedFileNames Include="@(FilesToPackage->'%(Filename)%(Extension)')"
                          Condition="'%(FilesToPackage.IsSymbolFile)' != 'true' and
                                      '%(FilesToPackage.GeneratedBuildFile)' != 'true' and
                                      '%(FilesToPackage.ExcludeFromDataFiles)' != 'true' and
                                      $([System.String]::new('%(FilesToPackage.TargetPath)').StartsWith('runtimes/'))"
                          OriginalFilePath="$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '%(Identity)'))" />
    </ItemGroup>

    <RemoveDuplicates Inputs="@(_PackagedFileNames)">
      <Output TaskParameter="Filtered" ItemName="_PackagedFileNamesFiltered" />
    </RemoveDuplicates>
  </Target>

  <!---
     ============== Templated Platform Manifest ================
     For shared frameworks with differing sets of files on various platforms
     and with no single platform that contains all of the files, this SDK provides support
     for creating a platform manifest from a templated list of items.

     Assumptions:
     - All managed assemblies are either present in both the ref and runtime pack for the shared framework
         or have an easily calculatable assembly version and file version.
     - All native files have an easily calculatable file version.

    To use, set UseTemplatedPlatformManifest to true and define a set of PlatformManifestFileEntry items

    PlatformManifestFileEntry metadata:
    - ItemSpec/Identity: File name and extension of file in the shared framework.
    - IsNative: true when the file is a native file
    - FallbackAssemblyVersion: An assembly version for this file if it is not present in the ref-pack build.
    - FallbackFileVersion: A file version for this file if it is not present in the ref-pack build.

    Properties for these targets:
    UseTemplatedPlatformManifest: Set to true to enable the templated platform manifest generation
    PlatformManifestFallbackAssemblyVersion: Fallback asssembly version when one is needed and there is no fallback on the entry.
    PlatformManifestFallbackFileVersion: Fallback file version when one is needed and there is no fallback on the entry.
  -->
  <Target Name="_SetDefaultPlatformManifestFallbackVersions" DependsOnTargets="GetAssemblyVersion" Condition="'$(UseDefaultPlatformManifestFallbackVersions)' == 'true'">
    <PropertyGroup>
      <PlatformManifestFallbackFileVersion>$(FileVersion)</PlatformManifestFallbackFileVersion>
      <PlatformManifestFallbackAssemblyVersion>$(AssemblyVersion)</PlatformManifestFallbackAssemblyVersion>
    </PropertyGroup>
  </Target>
  <Target Name="_ValidateAllFilesInTemplatedPlatformManifest"
          DependsOnTargets="_GetPackagedFileNamesNoDuplicates;_SetDefaultPlatformManifestFallbackVersions"
          Condition="'$(PlatformPackageType)' == 'RuntimePack' and '$(UseTemplatedPlatformManifest)' == 'true'">
    <ItemGroup>
      <_FilesMissingInManifestEntries Include="@(_PackagedFileNamesFiltered)" Exclude="@(PlatformManifestFileEntry)" />
    </ItemGroup>

    <Error Condition="'@(_FilesMissingInManifestEntries)' != ''"
           Text="The following files are missing entries in the templated manifest:&#10;@(_FilesMissingInManifestEntries, '&#10;'). Add these file names with extensions to the 'PlatformManifestFileEntry' item group for the runtime pack and corresponding ref pack to include them in the platform manifest." />
  </Target>

  <UsingTask TaskName="GeneratePlatformManifestEntriesFromTemplate" AssemblyFile="$(DotNetSharedFrameworkTaskFile)" />
  <Target Name="_GenerateTemplatedPlatformManifest"
          DependsOnTargets="GetFilesToPackage;_SetDefaultPlatformManifestFallbackVersions"
          Condition="'$(PlatformPackageType)' == 'TargetingPack' and '$(UseTemplatedPlatformManifest)' == 'true'">

    <GeneratePlatformManifestEntriesFromTemplate
      PlatformManifestEntryTemplates="@(PlatformManifestFileEntry)"
      Files="@(FilesToPackage)"
      FallbackAssemblyVersion="$(PlatformManifestFallbackAssemblyVersion)"
      FallbackFileVersion="$(PlatformManifestFallbackFileVersion)">
      <Output TaskParameter="PlatformManifestEntries" ItemName="_PlatformManifestEntry" />
    </GeneratePlatformManifestEntriesFromTemplate>
  </Target>

  <!--
      =============== Harvested Platform Manifest ================
      For platforms where all target platforms have the same files
      or where one platform has a superset of the files available
      on all platforms, we can generate a platform manifest from
      the present files in the runtime pack.

      This is enabled when UseTemplatedPlatformManifest is not set to true.

      Set the RuntimePackProjectPath to the path to the runtime pack shared framework project.

      If you only want to use one RID to generate the platform manifest, you can set
      the RuntimePackPlatformForManifest property to the RID you'd like to use.
      If the chosen RID doesn't have a superset of files for all shipping platforms,
      then you may have unexpected behavior when using the produced targeting pack.
  -->
  <UsingTask TaskName="GeneratePlatformManifestEntriesFromFileList" AssemblyFile="$(DotNetSharedFrameworkTaskFile)" />
  <Target Name="_GeneratePlatformManifestFromRuntimePack"
          DependsOnTargets="_CalculatePackageInformation"
          Condition="'$(PlatformPackageType)' == 'TargetingPack' and '$(UseTemplatedPlatformManifest)' != 'true'">

    <PropertyGroup>
      <_RuntimePackHarvestProperties Condition="'$(RuntimePackPlatformForManifest)' != ''">RuntimeIdentifier=$(RuntimePackPlatformForManifest)</_RuntimePackHarvestProperties>
      <_RuntimePackBuildTarget>_GetPackagedFileNamesNoDuplicates</_RuntimePackBuildTarget>
    </PropertyGroup>

    <Error Condition="'$(RuntimePackProjectPath)' == ''"
           Text="A runtime pack project is required for using a harvested platform manifest." />

    <MSBuild Projects="$(RuntimePackProjectPath)"
             Targets="_IsMultiRidBuild"
             Condition="'$(RuntimePackPlatformForManifest)' == ''">
      <Output TaskParameter="TargetOutputs" PropertyName="_RuntimePackIsMultiRid" />
    </MSBuild>

    <PropertyGroup Condition="'$(_RuntimePackIsMultiRid)' == 'true'">
      <_RuntimePackHarvestProperties>$(_RuntimePackHarvestProperties);InnerTargets=$(_RuntimePackBuildTarget)</_RuntimePackHarvestProperties>
      <_RuntimePackBuildTarget>Build</_RuntimePackBuildTarget>
    </PropertyGroup>

    <MSBuild Projects="$(RuntimePackProjectPath)"
             Targets="$(_RuntimePackBuildTarget)"
             Properties="$(_RuntimePackHarvestProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RuntimePackagedFileName" />
    </MSBuild>

    <RemoveDuplicates Inputs="@(_RuntimePackagedFileName)">
      <Output TaskParameter="Filtered" ItemName="_RuntimePackagedFileNamesNoDuplicates" />
    </RemoveDuplicates>

    <GeneratePlatformManifestEntriesFromFileList
      Files="@(_RuntimePackagedFileNamesNoDuplicates)">
      <Output TaskParameter="PlatformManifestEntries" ItemName="_PlatformManifestEntry" />
    </GeneratePlatformManifestEntriesFromFileList>
  </Target>

  <Target Name="_CreatePlatformManifest" DependsOnTargets="_GenerateTemplatedPlatformManifest;_GeneratePlatformManifestFromRuntimePack"
          Condition="'$(PlatformPackageType)' == 'TargetingPack'">
    <ItemGroup>
      <_PlatformManifestFile Include="$(IntermediateOutputPath)PlatformManifest.txt" TargetPath="data" GeneratedBuildFile="true" />
    </ItemGroup>

    <WriteLinesToFile
      Lines="@(_PlatformManifestEntry->'%(Identity)|$(PackageId)|%(AssemblyVersion)|%(FileVersion)')"
      File="@(_PlatformManifestFile)"
      WriteOnlyWhenDifferent="true"
      Overwrite="true" />

    <ItemGroup>
      <FileWrites Include="@(_PlatformManifestFile)" />
      <FilesToPackage Include="@(_PlatformManifestFile)" />
    </ItemGroup>
  </Target>

  <UsingTask TaskName="CreateFrameworkListFile" AssemblyFile="$(DotNetSharedFrameworkTaskFile)" />
  <Target Name="_GenerateFrameworkList"
          DependsOnTargets="GetFilesToPackage"
          Condition="'$(PlatformPackageType)' == 'TargetingPack' or '$(PlatformPackageType)' == 'RuntimePack'">
    <ItemGroup>
      <_FrameworkRuntimeList Include="$(IntermediateOutputPath)FrameworkList.xml"
                             Condition="'$(PlatformPackageType)' == 'TargetingPack'" />
      <_FrameworkRuntimeList Include="$(IntermediateOutputPath)RuntimeList.xml"
                             Condition="'$(PlatformPackageType)' == 'RuntimePack'" />
      <_FrameworkRuntimeList>
        <TargetPath>data</TargetPath>
      </_FrameworkRuntimeList>

      <_FrameworkListRootAttribute Include="TargetFrameworkIdentifier" Value="$(TargetFrameworkIdentifier)" />
      <_FrameworkListRootAttribute Include="TargetFrameworkVersion" Value="$(TargetFrameworkVersion.TrimStart('vV'))" />
      <_FrameworkListRootAttribute Include="FrameworkName" Value="$(SharedFrameworkName)" />
      <_FrameworkListRootAttribute Include="Name" Value="$(SharedFrameworkFriendlyName)" />
      <_FrameworkListTargetFilePrefix Include="ref/;runtimes/;analyzers/" />
      <_FrameworkListTargetFilePrefix Condition="'$(PlatformPackageType)' == 'RuntimePack'" Include="PgoData" />
    </ItemGroup>

    <CreateFrameworkListFile
      Files="@(FilesToPackage)"
      FileClassifications="@(FrameworkListFileClass)"
      TargetFile="@(_FrameworkRuntimeList)"
      TargetFilePrefixes="@(_FrameworkListTargetFilePrefix)"
      SingleFileHostIncludeFilenames="@(SingleFileHostIncludeFilename)"
      RootAttributes="@(_FrameworkListRootAttribute)" />
    <ItemGroup>
      <FileWrites Include="@(_FrameworkRuntimeList)" />
      <FilesToPackage Include="@(_FrameworkRuntimeList)" />
    </ItemGroup>
  </Target>

  <Target Name="_AddPackageOverridesToPackage"
          DependsOnTargets="CreatePackageOverrides"
          Condition="'$(PlatformPackageType)' == 'TargetingPack'">
    <ItemGroup>
      <PackageOverridesFile>
        <TargetPath>data</TargetPath>
      </PackageOverridesFile>
      <FilesToPackage Include="@(PackageOverridesFile)" />
    </ItemGroup>
  </Target>

  <Target Name="_CreateVersionsFile"
          DependsOnTargets="InitializeSourceControlInformationFromSourceControlManager"
          Condition="'$(DisableSourceLink)' != 'true'">
    <ItemGroup>
      <_VersionsFile Include="$(IntermediateOutputPath)$(SharedFrameworkName).versions.txt" TargetPath="" GeneratedBuildFile="true" />
      <!-- The presence of the .version file is used by VS to detect a valid installation of the shared framework into a .NET Runtime/SDK install. -->
      <_DotVersionFile Include="$(IntermediateOutputPath).version"
                       PublishOnly="true"
                       GeneratedBuildFile="true"
                       Condition="'$(PlatformPackageType)' == 'RuntimePack'" />
    </ItemGroup>
    <WriteLinesToFile
      Lines="$(SourceRevisionId);$(Version)"
      File="@(_VersionsFile)"
      Overwrite="true"
      WriteOnlyWhenDifferent="true" />
    <WriteLinesToFile
      Lines="$(SourceRevisionId);$(Version)"
      File="@(_DotVersionFile)"
      Overwrite="true"
      WriteOnlyWhenDifferent="true"
      Condition="'@(_DotVersionFile)' != ''" />
    <ItemGroup>
      <FileWrites Include="@(_VersionsFile);@(_DotVersionFile)" />
      <FilesToPackage Include="@(_VersionsFile);@(_DotVersionFile)" />
    </ItemGroup>
  </Target>

  <UsingTask TaskName="VerifyClosure" AssemblyFile="$(DotNetSharedFrameworkTaskFile)" />
  <Target Name="_VerifyClosure"
          DependsOnTargets="GetFilesToPackage"
          Condition="'$(SkipValidatePackage)' != 'true'">
    <ItemGroup>
      <_closureFiles
        Include="@(FilesToPackage)"
        Condition="('%(Extension)' == '.dll' or '%(Extension)' == '$(LibraryFileExtension)') and '%(FilesToPackage.Culture)' == '' and '%(FilesToPackage.ExcludeFromValidation)' != 'true'" />
      <_closureFileNames Include="@(_closureFiles->'%(FileName)')" Original="%(Identity)" />

      <_closureFileNamesFiltered Include="@(_closureFileNames)" Exclude="@(ExcludeFromClosure)"/>
      <_closureFileFiltered Include="@(_closureFileNamesFiltered->'%(Original)')"/>
    </ItemGroup>

    <ItemGroup Condition="'$(PlatformPackageType)' == 'RuntimePack'">
      <IgnoredReference Include="@(RuntimePackAsset->'%(FileName)')" />
    </ItemGroup>

    <ItemGroup Condition="'$(PlatformPackageType)' == 'TargetingPack'">
      <IgnoredReference Include="@(Reference->'%(FileName)')" Condition="'%(Reference.FrameworkReferenceName)' != ''" />
    </ItemGroup>

    <Message Text="Verifying closure of $(PackageId) assemblies" />
    <VerifyClosure
      Sources="@(_closureFileFiltered)"
      IgnoredReferences="@(IgnoredReference)"
      DependencyGraphFilePath="$(IntermediateOutputPath)assembly-graph.dgml" />
  </Target>

  <UsingTask TaskName="VerifyTypes" AssemblyFile="$(DotNetSharedFrameworkTaskFile)" />
  <Target Name="_VerifyNoDuplicateTypes"
          DependsOnTargets="GetFilesToPackage"
          Condition="'$(SkipValidatePackage)' != 'true'">

    <ItemGroup>
      <_dupTypeFiles
         Include="@(FilesToPackage)"
         Condition="('%(Extension)' == '.dll' or '%(Extension)' == '$(LibraryFileExtension)') and '%(FilesToPackage.Culture)' == '' and '%(FilesToPackage.ExcludeFromValidation)' != 'true'" />
      <_dupTypeFileName Include="@(_dupTypeFiles->'%(FileName)')" Original="%(Identity)" />

      <_dupTypeFileNamesFiltered Include="@(_dupTypeFileName)" Exclude="@(ExcludeFromDuplicateTypes)"/>
      <_dupTypeFileFiltered Include="@(_dupTypeFileNamesFiltered->'%(Original)')"/>
    </ItemGroup>

    <Message Text="Verifying no duplicate types in $(PackageId) assemblies" />
    <VerifyTypes
      Sources="@(_dupTypeFileFiltered)"
      IgnoredTypes="@(IgnoredDuplicateType)" />
  </Target>

  <UsingTask TaskName="ValidateFileVersions" AssemblyFile="$(DotNetSharedFrameworkTaskFile)" />
  <Target Name="_ValidateFileVersions"
          DependsOnTargets="GetFilesToPackage"
          Condition="'$(PermitDllAndExeFilesLackingFileVersion)' != 'true' and '$(PlatformPackageType)' == 'RuntimePack'">
    <ItemGroup>
      <_filesToVerify Include="@(FilesToPackage)" Condition="'%(Extension)' == '.dll' or '%(Extension)' == '.exe'" />
    </ItemGroup>
    <ValidateFileVersions Files="@(_filesToVerify)" />
  </Target>


  <Target Name="_GetAllSharedFrameworkFiles"
          DependsOnTargets="_CalculatePackageInformation;
                            GetFilesToPackage;
                            _GenerateSharedFrameworkDepsFile;
                            _GenerateSharedFrameworkRuntimeConfigFile;
                            _ValidateAllFilesInTemplatedPlatformManifest;
                            _CreatePlatformManifest;
                            _GenerateFrameworkList;
                            _AddPackageOverridesToPackage;
                            _CreateVersionsFile;
                            _VerifyClosure;
                            _VerifyNoDuplicateTypes;
                            _ValidateFileVersions"
          Returns="@(FilesToPackage)" />

  <Target Name="_AddFilesToNuGetPackage" BeforeTargets="_GetPackageFiles">

    <MSBuild Projects="$(MSBuildProjectFullPath)"
          Targets="_GetAllSharedFrameworkFiles"
          RemoveProperties="NoBuild">
      <Output TaskParameter="TargetOutputs" ItemName="_FilesToPackage" />
    </MSBuild>

    <PropertyGroup>
      <BuildOutputTargetFolder>runtimes/$(RuntimeIdentifier)/lib</BuildOutputTargetFolder>
      <IncludeBuildOutput>true</IncludeBuildOutput>
    </PropertyGroup>
    <ItemGroup>
      <_PackageFiles Include="@(_FilesToPackage)" PackagePath="%(_FilesToPackage.TargetPath)"
                    Condition="('%(_FilesToPackage.IsSymbolFile)' != 'true' and '%(_FilesToPackage.PublishOnly)' != 'true') or '%(_FilesToPackage.IncludeAlways)' == 'true'" />
      <!--
           We need to handle symbol files specially so they get correctly filtered out of the implementation package.
           The base of the TargetPath attribute is $(BuildOutputTargetFolder)/%(TargetFramework), so we have to
           modify the TargetPath metadata with that base path in mind.
      -->
      <_TargetPathsToSymbols Include="@(_FilesToPackage)"
                             Condition="'%(_FilesToPackage.IsSymbolFile)' == 'true' and '%(_FilesToPackage.PublishOnly)' != 'true' and '%(_FilesToPackage.IncludeAlways)' != 'true'"
                             TargetFramework="$(TargetFramework)"
                             TargetPath="$([MSBuild]::MakeRelative($([MSBuild]::NormalizePath('$(BuildOutputTargetFolder)/$(TargetFramework)')), $([MSBuild]::NormalizePath('%(_FilesToPackage.TargetPath)', '%(Filename)%(Extension)'))))"/>
    </ItemGroup>
  </Target>

  <Target Name="_CreateNuGetPackage" Condition="'$(SkipBuild)' != 'true'">
    <MSBuild Projects="$(MSBuildProjectFullPath)"
             Targets="Pack"
             Properties="NoBuild=true" />
  </Target>

  <Target Name="GetFilesToPublish">

    <MSBuild Projects="$(MSBuildProjectFullPath)"
          Targets="_GetAllSharedFrameworkFiles"
          RemoveProperties="OutputPath;SymbolsOutputPath">
      <Output TaskParameter="TargetOutputs" ItemName="_FilesToPackage" />
    </MSBuild>

    <ItemGroup>
      <_PackagedFilesToPublish Include="@(_FilesToPackage)" Condition="'%(_FilesToPackage.PackOnly)' != 'true'" />
    </ItemGroup>
    <ItemGroup Condition="'$(PlatformPackageType)' == 'RuntimePack'">
      <FilesToPublish Include="@(_PackagedFilesToPublish)"
                       Condition="$([System.String]::new('%(_PackagedFilesToPublish.TargetPath)').StartsWith('runtimes/'))"
                       TargetPath="shared/$(SharedFrameworkName)/$(Version)/" />
    </ItemGroup>
    <ItemGroup Condition="'$(PlatformPackageType)' == 'TargetingPack' or '$(PlatformPackageType)' == 'AppHostPack'">
      <FilesToPublish Include="@(_PackagedFilesToPublish)"
                      Condition="'%(_PackagedFilesToPublish.TargetPath)' != ''"
                      TargetPath="packs/$(PackageId)/$(Version)/%(_PackagedFilesToPublish.TargetPath)/"/>
    </ItemGroup>
  </Target>

  <Target Name="PublishToDisk"
          DependsOnTargets="GetFilesToPublish">
    <Error Condition="'$(OutputPath)' == ''" Text="Publishing a shared framework to disk requires the OutputPath to be set to the root of the path to write to." />
    <Copy
      SourceFiles="@(FilesToPublish)"
      DestinationFolder="$(OutputPath)%(FilesToPublish.TargetPath)%(FilesToPublish.Culture)"
      Condition="'%(FilesToPublish.IsSymbolFile)' != 'true' or '%(FilesToPublish.IncludeAlways)' == 'true'"
      OverwriteReadOnlyFiles="true"
      SkipUnchangedFiles="true" />

    <!-- Fix file permissions in the layout dir. -->
    <!-- Reset everything to user readable/writeable and group and world readable. -->
    <Exec Condition="!$([MSBuild]::IsOsPlatform(Windows))" Command='find "$(OutputPath)" -type f -name "*" -exec chmod 644 {} \;' />
    <!-- Generally, dylibs and sos have 'x'. -->
    <Exec Condition="!$([MSBuild]::IsOsPlatform(Windows))" Command='find "$(OutputPath)" -type f -name "*.dylib" -exec chmod 755 {} \;' />
    <Exec Condition="!$([MSBuild]::IsOsPlatform(Windows))" Command='find "$(OutputPath)" -type f -name "*.so" -exec chmod 755 {} \;' />
    <!-- Executables (those without dots) are executable. -->
    <Exec Condition="!$([MSBuild]::IsOsPlatform(Windows))" Command='find "$(OutputPath)" -type f ! -name "*.*" -exec chmod 755 {} \;' />
  </Target>

  <Target Name="PublishSymbolsToDisk"
          DependsOnTargets="GetFilesToPublish">
    <Error Condition="'$(SymbolsOutputPath)' == ''" Text="Publishing a shared framework to disk requires the OutputPath to be set to the root of the path to write to." />
    <Copy
      SourceFiles="@(FilesToPublish)"
      DestinationFolder="$(SymbolsOutputPath)%(FilesToPublish.Culture)"
      Condition="'%(FilesToPublish.IsSymbolFile)' == 'true'"
      OverwriteReadOnlyFiles="true"
      SkipUnchangedFiles="true" />
  </Target>

  <PropertyGroup>
    <BuildDependsOn>$(BuildDependsOn);_GetSkipBuildProps;_CreateNuGetPackage</BuildDependsOn>
  </PropertyGroup>
</Project>
