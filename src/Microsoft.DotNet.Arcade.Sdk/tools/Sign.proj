<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
<Project DefaultTargets="Sign">

  <!--
    Documentation for publishing is available here:
      - https://github.com/dotnet/arcade/blob/master/Documentation/CorePackages/Signing.md
  
    Optional variables:
      EnableDefaultArtifacts            Includes *.nupkg, *.vsix and *.wixpack.zip under "/artifacts/packages/**" for sigining.
                                        Defaults to true.

    Optional items:
      Artifact (with Metadata)          Path to the artifact to publish. Declare the item in Signing.props to sign and publish the artifact.
        - SkipPublish                     If true, skips publishing the artifact.
  -->

  <PropertyGroup>
    <!-- Disable target framework filtering for top level projects -->
    <NoTargetFrameworkFiltering>true</NoTargetFrameworkFiltering>
  </PropertyGroup>

  <Import Project="BuildStep.props" />

  <!-- Properties requires by NuGet.targets to restore PackageReferences -->
  <PropertyGroup>
    <TargetFramework>net472</TargetFramework>
    <!-- Workaround changes from newer MSBuild requiring additional properties -->
    <TargetFrameworkVersion Condition="'$(TargetFrameworkVersion)' == ''">5</TargetFrameworkVersion>
    <TargetFrameworkIdentifier  Condition="'$(TargetFrameworkIdentifier)' == ''">.NETFramework</TargetFrameworkIdentifier>
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == ''">.NETFramework,Version=v4.7.2</TargetFrameworkMoniker>
    <MSBuildProjectExtensionsPath>$(BaseIntermediateOutputPath)</MSBuildProjectExtensionsPath>
  </PropertyGroup>

  <!-- 
    Configure NuGet Restore to use NuGet.config file in the repository root.
    We could drop a custom NuGet.config to the containing directory but it's simpler
    if we use the same config for all restore operations.
    NuGet.Config, NuGet.config, and nuget.config are all allowed casings according to NuGet:
    https://github.com/NuGet/NuGet.Client/blob/b83566ec2369c4e9fd07e6f95d734dfe370a1e66/src/NuGet.Core/NuGet.Configuration/Settings/Settings.cs#L34-L36
  -->
  <PropertyGroup Condition="'$(RestoreConfigFile)' == ''">
    <RestoreConfigFile Condition="Exists('$(RepoRoot)NuGet.config')">$(RepoRoot)NuGet.config</RestoreConfigFile>
    <RestoreConfigFile Condition="Exists('$(RepoRoot)NuGet.Config')">$(RepoRoot)NuGet.Config</RestoreConfigFile>
    <RestoreConfigFile Condition="Exists('$(RepoRoot)nuget.config')">$(RepoRoot)nuget.config</RestoreConfigFile>
  </PropertyGroup>

  <Import Project="$(_NuGetRestoreTargets)" />

  <!-- These package references should only be excluded when doing inner builds, and outer-builds from the orchestrator in source only build
       configurations. non-source only build configurations should always restore these packages.

       Switches are separated by legacy vs. new.

       This looks complicated right now, but will get simpler as legacy switches disappear:
       - ArcadeInnerBuildFromSource/DotNetBuildFromSource disappear:
         ('$(DotNetBuildSourceOnly)' != 'true' or ('$(DotNetBuildPhase)' == 'Repo' and '$(DotNetBuildOrchestrator)' != 'true')
  -->

  <PropertyGroup>
    <_ImportOrUseTooling>false</_ImportOrUseTooling>
    <_ImportOrUseTooling Condition="('$(ArcadeInnerBuildFromSource)' != 'true' and '$(DotNetBuildFromSourceFlavor)' != 'Product') and 
                                    ('$(DotNetBuildSourceOnly)' != 'true' or ('$(DotNetBuildPhase)' == 'Repo' and '$(DotNetBuildOrchestrator)' != 'true'))">true</_ImportOrUseTooling>
  </PropertyGroup>

  <ItemGroup Condition="'$(_ImportOrUseTooling)' == 'true'">
    <!-- Copy of 'sn.exe' in form of NuGet package. -->
    <PackageReference Include="sn" Version="$(SNVersion)" IsImplicitlyDefined="true" />
    <PackageReference Include="MicroBuild.Core" Version="$(MicroBuildCoreVersion)"  IsImplicitlyDefined="true" />
    <PackageReference Include="MicroBuild.Core.Sentinel" Version="1.0.0" IsImplicitlyDefined="true" />
    <PackageReference Include="vswhere" Version="$(VSWhereVersion)" IsImplicitlyDefined="true" />
    <PackageReference Include="Microsoft.Signed.Wix" Version="$(MicrosoftSignedWixVersion)" IsImplicitlyDefined="true" />
    <PackageReference Include="Microsoft.DotNet.SignTool" Version="$(MicrosoftDotNetSignToolVersion)" IsImplicitlyDefined="true" />
  </ItemGroup>

  <Import Project="$(NuGetPackageRoot)microsoft.dotnet.signtool\$(MicrosoftDotNetSignToolVersion)\build\Microsoft.DotNet.SignTool.props" />

  <Import Project="Sign.props" />

  <!-- Import the wix props to get the install path -->
  <Import Project="$(NuGetPackageRoot)microsoft.signed.wix\$(MicrosoftSignedWixVersion)\build\Microsoft.Signed.Wix.props" />

  <!-- Update sign infos that were using Microsoft400 to use the .NET-specific cert if UseDotNetCertificate is present.
       This will update any use, even if explicitly specified.
       NOTE: This is outside the target on purpose, as Update will not correctly evaluate in the target. See
       https://github.com/dotnet/msbuild/issues/1618. -->
  <ItemGroup Condition="$(UseDotNetCertificate)">
    <FileExtensionSignInfo Update="@(FileExtensionSignInfo->WithMetadataValue('CertificateName','Microsoft400'))" CertificateName="$(DotNetCertificateName)" />
    <StrongNameSignInfo Update="@(StrongNameSignInfo->WithMetadataValue('CertificateName','Microsoft400'))" CertificateName="$(DotNetCertificateName)" />
    <FileSignInfo Update="@(FileSignInfo->WithMetadataValue('CertificateName','Microsoft400'))" CertificateName="$(DotNetCertificateName)" />
  </ItemGroup>

  <Target Name="Sign">
    <Error Text="The value of DotNetSignType is invalid: '$(DotNetSignType)'"
           Condition="'$(DotNetSignType)' != 'real' and '$(DotNetSignType)' != 'test' and '$(DotNetSignType)' != ''" />

    <PropertyGroup>
      <_DryRun>true</_DryRun>
      <_DryRun Condition="'$(OfficialBuild)' == 'true'">false</_DryRun>

      <_TestSign>false</_TestSign>
      <_TestSign Condition="'$(DotNetSignType)' == 'test'">true</_TestSign>

      <_DesktopMSBuildRequired>false</_DesktopMSBuildRequired>
      <_DesktopMSBuildRequired Condition="'$(_DryRun)' != 'true' and '$(MSBuildRuntimeType)' == 'Core'">true</_DesktopMSBuildRequired>
    </PropertyGroup>

    <Error Condition="'$(AllowEmptySignList)' != 'true' AND '@(ItemsToSign)' == ''" 
           Text="List of files to sign is empty. Make sure that ItemsToSign is configured correctly." />

    <!-- We only need this if we are going to use the executable version. -->
    <Exec Command='"$(NuGetPackageRoot)vswhere\$(VSWhereVersion)\tools\vswhere.exe" -latest -prerelease -property installationPath -requires Microsoft.Component.MSBuild'
          ConsoleToMsBuild="true"
          StandardErrorImportance="high"
          Condition="$(_DesktopMSBuildRequired)">
      <Output TaskParameter="ConsoleOutput" PropertyName="_VSInstallDir" />
    </Exec>

    <PropertyGroup Condition="$(_DesktopMSBuildRequired)">
      <_DesktopMSBuildPath>$(_VSInstallDir)\MSBuild\Current\Bin\msbuild.exe</_DesktopMSBuildPath>
      <_DesktopMSBuildPath Condition="!Exists('$(_DesktopMSBuildPath)')">$(_VSInstallDir)\MSBuild\15.0\Bin\msbuild.exe</_DesktopMSBuildPath>
    </PropertyGroup>

    <Microsoft.DotNet.SignTool.SignToolTask
        DryRun="$(_DryRun)"
        TestSign="$(_TestSign)"
        DoStrongNameCheck="$(DoStrongNameCheck)"
        AllowEmptySignList="$(AllowEmptySignList)"
        CertificatesSignInfo="@(CertificatesSignInfo)"
        ItemsToSign="@(ItemsToSign)"
        StrongNameSignInfo="@(StrongNameSignInfo)"
        FileSignInfo="@(FileSignInfo)"
        FileExtensionSignInfo="@(FileExtensionSignInfo)"
        TempDir="$(ArtifactsTmpDir)"
        LogDir="$(ArtifactsLogDir)"
        MSBuildPath="$(_DesktopMSBuildPath)"
        SNBinaryPath="$(NuGetPackageRoot)sn\$(SNVersion)\sn.exe"
        MicroBuildCorePath="$(NuGetPackageRoot)microbuild.core\$(MicroBuildCoreVersion)"
        WixToolsPath="$(WixInstallPath)"
        TarToolPath="$(NuGetPackageRoot)microsoft.dotnet.tar\$(MicrosoftDotNetSignToolVersion)\tools\net9.0\any\Microsoft.Dotnet.Tar.dll"
        RepackParallelism="$(SignToolRepackParallelism)"
        MaximumParallelFileSize="$(SignToolRepackMaximumParallelFileSize)" />
  </Target>

</Project>
